// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

enum ReplayStatus {
  DISCOVERED
  DOWNLOADED
  PARSED
  ERROR
}

enum GameType {
  SG
  MACE
  SM
}

enum EntityType {
  UNIT
  VEHICLE
}

enum EntitySide {
  EAST
  WEST
  GUER
  CIV
  UNKNOWN
}

enum EventType {
  KILLED
  CONNECTED
  DISCONNECTED
}

enum CorrectionType {
  ADD_KILL
  ADD_TEAMKILL
  REMOVE_TEAMKILL
  ADD_VEHICLE_KILL
  REMOVE_PLAYER
}

model Replay {
  id            String        @id @default(uuid())
  filename      String        @unique
  missionName   String
  date          DateTime
  gameType      GameType
  replayLink    String
  status        ReplayStatus  @default(DISCOVERED)
  discoveredAt  DateTime      @default(now())
  parsedAt      DateTime?
  
  entities      Entity[]
  events        Event[]
  playerResults PlayerReplayResult[]
  corrections   Correction[]
  
  @@index([status, gameType])
}

model Entity {
  id          String      @id @default(uuid())
  replayId    String
  entityId    Int
  type        EntityType
  name        String
  side        EntitySide
  isPlayer    Boolean
  
  replay      Replay @relation(fields: [replayId], references: [id], onDelete: Cascade)
  
  @@unique([replayId, entityId])
  @@index([replayId, entityId])
}

model Event {
  id          String      @id @default(uuid())
  replayId    String
  frameId     Int
  eventType   EventType
  data        String      // JSON as text for SQLite
  
  replay      Replay @relation(fields: [replayId], references: [id], onDelete: Cascade)
  
  @@index([replayId, eventType])
}

model Player {
  id            String    @id @default(uuid())
  createdAt     DateTime  @default(now())
  
  names         PlayerName[]
  replayResults PlayerReplayResult[]
  corrections   Correction[]
}

model PlayerName {
  id          String    @id @default(uuid())
  playerId    String
  name        String
  validFrom   DateTime
  validTo     DateTime?
  
  player      Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  
  @@index([name, validFrom, validTo])
}

model PlayerReplayResult {
  id                String  @id @default(uuid())
  replayId          String
  playerId          String
  entityName        String
  squadPrefix       String?
  kills             Int
  killsFromVehicle  Int
  vehicleKills      Int
  teamkills         Int
  deaths            Int
  deathsByTeamkills Int
  isDead            Boolean
  isDeadByTeamkill  Boolean
  score             Float
  
  // JSON fields stored as text in SQLite
  weapons           String  // WeaponStatistic[]
  vehicles          String  // WeaponStatistic[]
  killed            String  // OtherPlayer[]
  killers           String  // OtherPlayer[]
  teamkilled        String  // OtherPlayer[]
  teamkillers       String  // OtherPlayer[]
  
  replay            Replay @relation(fields: [replayId], references: [id], onDelete: Cascade)
  player            Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  
  @@unique([replayId, playerId])
  @@index([playerId])
}

model Correction {
  id              String          @id @default(uuid())
  replayId        String
  playerId        String
  correctionType  CorrectionType
  targetPlayerId  String?
  data            String          // JSON as text
  createdAt       DateTime        @default(now())
  createdBy       String
  applied         Boolean         @default(false)
  
  replay          Replay @relation(fields: [replayId], references: [id], onDelete: Cascade)
  player          Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  
  @@index([replayId, playerId])
  @@index([applied])
}
